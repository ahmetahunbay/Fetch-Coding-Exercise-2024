1. I chose to use Go as the main programming language. This is because I have not used the language since my summer with Fetch, and I wanted a refresher. I used SQLite as a persistent DB because it is light and relatively simple to implement. I also used some Go libraries to set up my heap and to get uuids. These packages helped a lot in making the process more streamlined. I also used Postman to make calling the endpoints much easier.

2. Some of the advantages of my solution are that I used a database and a cache, which made my api endpoints pretty fast, and the data was persistent across sessions. Since I used a heap, all of my routes had low runtime complexity (/add in O(nlogn) but usually O(logn), /spend in O(nlogn), /balance in O(n)). However, there were a few drawbacks to my solution. I was originally just going to keep a few global variables as my data store, but I realized this could be interpreted as breaking the stateless server REST guideline. I then decided to keep a DB in SQLite and a cache as a global var. This was much more complex than just having global variables to store data from API calls. Another thing is that my code does not have 100% guaranteed consistency between the cache and data store. I ran out of time before I could implement this. Also, I ran out of time before I could write up testers and create interfaces to do mock tests and dependency injections -- something I was hoping to get done. Overall, I built a working project that follows the guidelines, but could have potentially been stronger.

3. So far, my favorite school project has been the heap allocater that I made for my Computer Organization and Programming class. I coded this in C. This project dealt with a lot of tough logic and math to track heap space and allocate data. The project gave me a deeper understanding of low-level memory allocation that is used by high-level languages. Coding at such a low level was facinating for me and this project introduced me to to the complex logic of low-level programming. 
